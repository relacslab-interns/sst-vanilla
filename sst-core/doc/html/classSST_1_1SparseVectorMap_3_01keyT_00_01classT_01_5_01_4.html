<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SST: SST::SparseVectorMap&lt; keyT, classT * &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SST
   &#160;<span id="projectnumber">12.1.0</span>
   </div>
   <div id="projectbrief">StructuralSimulationToolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">SST::SparseVectorMap&lt; keyT, classT * &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that stores data in a vector, but can access the data similar to a map.  
 <a href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparseVectorMap_8h_source.html">sparseVectorMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8fe6a3efa6a4d8db4ab35a5f72f0ac73"><td class="memItemLeft" align="right" valign="top"><a id="a8fe6a3efa6a4d8db4ab35a5f72f0ac73"></a>
typedef std::vector&lt; classT * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a8fe6a3efa6a4d8db4ab35a5f72f0ac73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eaf09ac8383eee6d69b7eb7eaed0fb"><td class="memItemLeft" align="right" valign="top"><a id="a98eaf09ac8383eee6d69b7eb7eaed0fb"></a>
typedef std::vector&lt; classT * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a98eaf09ac8383eee6d69b7eb7eaed0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a862c1857507c80d4bf4eb37095051fbe"><td class="memItemLeft" align="right" valign="top"><a id="a862c1857507c80d4bf4eb37095051fbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a862c1857507c80d4bf4eb37095051fbe">SparseVectorMap</a> ()</td></tr>
<tr class="memdesc:a862c1857507c80d4bf4eb37095051fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. <br /></td></tr>
<tr class="separator:a862c1857507c80d4bf4eb37095051fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b32ed5b40bf582c14fffdc89eab1321"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a7b32ed5b40bf582c14fffdc89eab1321">SparseVectorMap</a> (std::vector&lt; classT *&gt; &amp;new_data, bool sorted=false)</td></tr>
<tr class="memdesc:a7b32ed5b40bf582c14fffdc89eab1321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows you to pass an already filled in array with data.  <a href="#a7b32ed5b40bf582c14fffdc89eab1321">More...</a><br /></td></tr>
<tr class="separator:a7b32ed5b40bf582c14fffdc89eab1321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b536563cec2bcbd4c643111c084024"><td class="memItemLeft" align="right" valign="top">classT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a54b536563cec2bcbd4c643111c084024">insert</a> (classT *val)</td></tr>
<tr class="memdesc:a54b536563cec2bcbd4c643111c084024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new value into <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>.  <a href="#a54b536563cec2bcbd4c643111c084024">More...</a><br /></td></tr>
<tr class="separator:a54b536563cec2bcbd4c643111c084024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9d2fb39d9d039096ccf73cafa5c1da"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a2f9d2fb39d9d039096ccf73cafa5c1da">begin</a> ()</td></tr>
<tr class="memdesc:a2f9d2fb39d9d039096ccf73cafa5c1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the begin iterator to the underlying vector.  <a href="#a2f9d2fb39d9d039096ccf73cafa5c1da">More...</a><br /></td></tr>
<tr class="separator:a2f9d2fb39d9d039096ccf73cafa5c1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294f1e5da230e6ae09fb95899f7acf58"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a294f1e5da230e6ae09fb95899f7acf58">end</a> ()</td></tr>
<tr class="memdesc:a294f1e5da230e6ae09fb95899f7acf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the end iterator to the underlying vector.  <a href="#a294f1e5da230e6ae09fb95899f7acf58">More...</a><br /></td></tr>
<tr class="separator:a294f1e5da230e6ae09fb95899f7acf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b1624fa8f68d8c0db3e4b1378092e1"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a52b1624fa8f68d8c0db3e4b1378092e1">begin</a> () const</td></tr>
<tr class="memdesc:a52b1624fa8f68d8c0db3e4b1378092e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the const begin iterator to the underlying vector.  <a href="#a52b1624fa8f68d8c0db3e4b1378092e1">More...</a><br /></td></tr>
<tr class="separator:a52b1624fa8f68d8c0db3e4b1378092e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ebca8f3bb4715ad5e6441342e198bf"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#aa2ebca8f3bb4715ad5e6441342e198bf">end</a> () const</td></tr>
<tr class="memdesc:aa2ebca8f3bb4715ad5e6441342e198bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the const end iterator to the underlying vector.  <a href="#aa2ebca8f3bb4715ad5e6441342e198bf">More...</a><br /></td></tr>
<tr class="separator:aa2ebca8f3bb4715ad5e6441342e198bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f59aa98d513a446564fa6a83db7b990"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a4f59aa98d513a446564fa6a83db7b990">contains</a> (keyT id) const</td></tr>
<tr class="memdesc:a4f59aa98d513a446564fa6a83db7b990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided id is found in the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>.  <a href="#a4f59aa98d513a446564fa6a83db7b990">More...</a><br /></td></tr>
<tr class="separator:a4f59aa98d513a446564fa6a83db7b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8007007f1b619170698f2b20856040"><td class="memItemLeft" align="right" valign="top">classT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a7a8007007f1b619170698f2b20856040">operator[]</a> (keyT id)</td></tr>
<tr class="memdesc:a7a8007007f1b619170698f2b20856040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator returns a reference to data with the specified id.  <a href="#a7a8007007f1b619170698f2b20856040">More...</a><br /></td></tr>
<tr class="separator:a7a8007007f1b619170698f2b20856040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a14c74814735603aaff55d69532f24"><td class="memItemLeft" align="right" valign="top">const classT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a94a14c74814735603aaff55d69532f24">operator[]</a> (keyT id) const</td></tr>
<tr class="memdesc:a94a14c74814735603aaff55d69532f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator returns a const reference to data with the specified id.  <a href="#a94a14c74814735603aaff55d69532f24">More...</a><br /></td></tr>
<tr class="separator:a94a14c74814735603aaff55d69532f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5b25dcd9edfbcbba2328346278fcd8"><td class="memItemLeft" align="right" valign="top"><a id="a4f5b25dcd9edfbcbba2328346278fcd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a4f5b25dcd9edfbcbba2328346278fcd8">clear</a> ()</td></tr>
<tr class="memdesc:a4f5b25dcd9edfbcbba2328346278fcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents of the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. <br /></td></tr>
<tr class="separator:a4f5b25dcd9edfbcbba2328346278fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf2002dcf9c7479f1ed8f8ddacd0559"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a0bf2002dcf9c7479f1ed8f8ddacd0559">size</a> ()</td></tr>
<tr class="memdesc:a0bf2002dcf9c7479f1ed8f8ddacd0559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items in the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>.  <a href="#a0bf2002dcf9c7479f1ed8f8ddacd0559">More...</a><br /></td></tr>
<tr class="separator:a0bf2002dcf9c7479f1ed8f8ddacd0559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312d578ab889dcaa867cb4fe1c88f33e"><td class="memTemplParams" colspan="2">template&lt;typename filterT &gt; </td></tr>
<tr class="memitem:a312d578ab889dcaa867cb4fe1c88f33e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a312d578ab889dcaa867cb4fe1c88f33e">filter</a> (filterT &amp;filt)</td></tr>
<tr class="memdesc:a312d578ab889dcaa867cb4fe1c88f33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to filter the contents of the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>.  <a href="#a312d578ab889dcaa867cb4fe1c88f33e">More...</a><br /></td></tr>
<tr class="separator:a312d578ab889dcaa867cb4fe1c88f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abaa034847476b3000c70290f5fe526f3"><td class="memItemLeft" align="right" valign="top"><a id="abaa034847476b3000c70290f5fe526f3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SST::Core::Serialization::serialize&lt; SparseVectorMap&lt; keyT, classT *&gt; &gt;</b></td></tr>
<tr class="separator:abaa034847476b3000c70290f5fe526f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeae9ced43d2d1dea9eea33bd767ca9"><td class="memItemLeft" align="right" valign="top"><a id="acbeae9ced43d2d1dea9eea33bd767ca9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ConfigGraph</b></td></tr>
<tr class="separator:acbeae9ced43d2d1dea9eea33bd767ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename keyT, typename classT&gt;<br />
class SST::SparseVectorMap&lt; keyT, classT * &gt;</h3>

<p>Class that stores data in a vector, but can access the data similar to a map. </p>
<p>The data structure is O(log n) on reads, but is O(n) to insert. The primary use case is when data is inserted in order, but accessed randomly. You can also create the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a> with a vector already loaded with the data. If the data is not already sorted, it will call std::sort on the data, which likely has an average complexity of O(n log n). This data structure should not be used for large lists where inserts do not happen in sorted order.</p>
<p>NOTE: Since the data is stored in the vector, reference returned from the various accessor functions will not be valid longterm. If an insert causes the vector to be resized, all references returned before that reallocation may (likely will) be invalid. References are only guaranteed to be valid until the next write to the data structure. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7b32ed5b40bf582c14fffdc89eab1321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b32ed5b40bf582c14fffdc89eab1321">&#9670;&nbsp;</a></span>SparseVectorMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::<a class="el" href="classSST_1_1SparseVectorMap.html">SparseVectorMap</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; classT *&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that allows you to pass an already filled in array with data. </p>
<p>The data in the passed in vector will be swapped into the data vector of the sparsevectormap and the passed in vector will be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_data</td><td>Vector of data to swap into the sparsevectormap data</td></tr>
    <tr><td class="paramname">sorted</td><td>Specifies whether the vector is already sorted in ascending order. if not, it will be sorted after swapping the data in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f9d2fb39d9d039096ccf73cafa5c1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9d2fb39d9d039096ccf73cafa5c1da">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the begin iterator to the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>begin iterator to data vector </dd></dl>

</div>
</div>
<a id="a52b1624fa8f68d8c0db3e4b1378092e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b1624fa8f68d8c0db3e4b1378092e1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the const begin iterator to the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>const begin iterator to data vector </dd></dl>

</div>
</div>
<a id="a4f59aa98d513a446564fa6a83db7b990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f59aa98d513a446564fa6a83db7b990">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">keyT&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the provided id is found in the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id to check for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if id is found, false otherwise </dd></dl>

</div>
</div>
<a id="a294f1e5da230e6ae09fb95899f7acf58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294f1e5da230e6ae09fb95899f7acf58">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the end iterator to the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>end iterator to data vector </dd></dl>

</div>
</div>
<a id="aa2ebca8f3bb4715ad5e6441342e198bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ebca8f3bb4715ad5e6441342e198bf">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the const end iterator to the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>const end iterator to data vector </dd></dl>

</div>
</div>
<a id="a312d578ab889dcaa867cb4fe1c88f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312d578ab889dcaa867cb4fe1c88f33e">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<div class="memtemplate">
template&lt;typename filterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">filterT &amp;&#160;</td>
          <td class="paramname"><em>filt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to filter the contents of the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. </p>
<p>Takes an object with an overloaded operator() function that takes as argument the current item. The funtion returns the object that should take the place of this object (value returned by key() function must be same for both objects), or returns nullptr if the object should be deleted. When an item is deleted, the size of the map reduces by 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filt</td><td>Filter object to use for filtering contents of map</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSST_1_1bad__filtered__key__error.html" title="Exception that is thrown by SparseVectorMap::filter() if the filtering object returns an object that ...">bad_filtered_key_error</a></td><td>filter returned an object that didn't return the same value on a call to key() as the original object in the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54b536563cec2bcbd4c643111c084024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b536563cec2bcbd4c643111c084024">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">classT* <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">classT *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new value into <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. </p>
<p>The inserted class must have a key() function with return type keyT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to add to <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the inserted item, or to the existing item if it was already present in the map. </dd></dl>

</div>
</div>
<a id="a7a8007007f1b619170698f2b20856040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8007007f1b619170698f2b20856040">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">classT* <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">keyT&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator returns a reference to data with the specified id. </p>
<p>Value can be modified. This will only return references to existing values, you must use <a class="el" href="classSST_1_1SparseVectorMap.html#a0f425059bccf1f7ddd10df22cd57e93b" title="Insert new value into SparseVectorMap. ">insert()</a> for new values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of the value to return (value returned by key())</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the requested item. </dd></dl>

</div>
</div>
<a id="a94a14c74814735603aaff55d69532f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a14c74814735603aaff55d69532f24">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const classT* <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">keyT&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator returns a const reference to data with the specified id. </p>
<p>Value cannot be modified. This will only return references to existing values, you must use <a class="el" href="classSST_1_1SparseVectorMap.html#a0f425059bccf1f7ddd10df22cd57e93b" title="Insert new value into SparseVectorMap. ">insert()</a> for new values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of the value to return (value returned by key())</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const reference to the requested item. </dd></dl>

</div>
</div>
<a id="a0bf2002dcf9c7479f1ed8f8ddacd0559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf2002dcf9c7479f1ed8f8ddacd0559">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items in the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>number of items </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/sst/core/<a class="el" href="sparseVectorMap_8h_source.html">sparseVectorMap.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>SST</b></li><li class="navelem"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html">SparseVectorMap&lt; keyT, classT * &gt;</a></li>
    <li class="footer">Generated on Tue Dec 13 2022 12:42:34 for SST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
